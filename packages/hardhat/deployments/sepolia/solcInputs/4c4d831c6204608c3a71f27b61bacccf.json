{
  "language": "Solidity",
  "sources": {
    "contracts/BlindAuction.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// @title 盲拍（Blind Auction）智能合约\n/// @notice 该合约允许用户进行匿名竞标，之后再披露出价，保障竞标的公平性    \ncontract BlindAuction {\n    // 结构体：表示一个盲拍出价，包含加密后的出价和押金\n    struct Bid {\n        bytes32 blindedBid; // 使用 keccak256(value, fake, secret) 生成的哈希值\n        uint deposit;       // 随出价一同发送的押金\n    }\n\n    address payable public beneficiary; // 拍卖受益人，最终收到最高出价金额的人\n    uint public biddingStart;           // 竞标开始时间（时间戳）\n    uint public biddingEnd;             // 竞标结束时间（时间戳）\n    uint public revealEnd;              // 披露阶段结束时间（时间戳）\n    bool public ended;                  // 拍卖是否已结束\n\n    mapping(address => Bid[]) public bids; // 每个地址对应的出价列表\n\n    address public highestBidder; // 当前最高出价者\n    uint public highestBid;       // 当前最高出价金额\n\n    // 可取回的竞标押金（如果不是最高出价）\n    mapping(address => uint) pendingReturns;\n\n    // 拍卖结束事件\n    event AuctionEnded(address winner, uint highestBid);\n    // 增加竞标事件便于前端监听\n    event BidSubmitted(address bidder, uint deposit);\n    // 披露竞标结果事件\n    event BidRevealed(address bidder, uint value, bool success);\n\n    // 自定义错误信息（gas 优化方式）\n    error TooEarly(uint time);             // 函数调用过早\n    error TooLate(uint time);              // 函数调用过晚\n    error AuctionEndAlreadyCalled();       // auctionEnd 函数已被调用过\n\n    /// 修饰符：要求当前时间小于指定时间，主要用于限制 bid 阶段调用\n    modifier onlyBefore(uint time) {\n        if (block.timestamp >= time) revert TooLate(time);\n        _;\n    }\n\n    /// 修饰符：要求当前时间大于指定时间，主要用于 reveal 和 auctionEnd\n    modifier onlyAfter(uint time) {\n        if (block.timestamp <= time) revert TooEarly(time);\n        _;\n    }\n\n    /// 构造函数，初始化受益人、竞标开始时间和各阶段时长\n    /// @param startTime 竞标开始时间（时间戳）\n    /// @param biddingTime 竞标阶段的持续时间（秒）\n    /// @param revealTime 披露阶段的持续时间（秒）\n    /// @param beneficiaryAddress 受益人地址\n    constructor(\n        uint startTime,\n        uint biddingTime,\n        uint revealTime,\n        address payable beneficiaryAddress\n    ) {\n        beneficiary = beneficiaryAddress;\n        biddingStart = startTime;\n        biddingEnd = startTime + biddingTime;\n        revealEnd = biddingEnd + revealTime;\n    }\n\n    /// 用户提交盲拍（加密的出价）\n    /// @param blindedBid 加密后的出价值（keccak256(value, fake, secret)）\n    function bid(bytes32 blindedBid)\n        external\n        payable\n        onlyAfter(biddingStart)  // 只能在竞标开始后调用\n        onlyBefore(biddingEnd)   // 只能在竞标阶段调用\n    {\n        // 将出价加入当前用户的出价列表\n        bids[msg.sender].push(Bid({\n            blindedBid: blindedBid,\n            deposit: msg.value\n        }));\n        \n        // 触发竞标事件\n        emit BidSubmitted(msg.sender, msg.value);\n    }\n\n    /// 披露阶段：用户公开其盲拍的真实数据\n    /// @param values 出价金额数组\n    /// @param fakes 是否为假出价（true 表示该出价为虚假）\n    /// @param secrets 每个出价对应的私密值\n    function reveal(\n        uint[] calldata values,\n        bool[] calldata fakes,\n        bytes32[] calldata secrets\n    )\n        external\n        onlyAfter(biddingEnd)    // 只能在竞标结束后调用\n        onlyBefore(revealEnd)    // 且必须在披露阶段结束前\n    {\n        uint length = bids[msg.sender].length;\n        require(values.length == length, \"Array lengths do not match\");\n        require(fakes.length == length, \"Array lengths do not match\");\n        require(secrets.length == length, \"Array lengths do not match\");\n\n        uint refund = 0; // 最终需要退还的金额\n\n        for (uint i = 0; i < length; i++) {\n            Bid storage bidToCheck = bids[msg.sender][i];\n\n            // 拿到用户的披露数据\n            (uint value, bool fake, bytes32 secret) =\n                    (values[i], fakes[i], secrets[i]);\n\n            // 校验 hash 是否一致，验证盲拍的合法性\n            if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) {\n                // 如果不一致，则该出价作废，不退还押金\n                continue;\n            }\n\n            refund += bidToCheck.deposit; // 押金暂时计入退款\n\n            // 如果不是假出价，并且押金大于等于出价金额\n            if (!fake && bidToCheck.deposit >= value) {\n                // 尝试将其设置为当前最高出价\n                if (placeBid(msg.sender, value)) {\n                    refund -= value; // 成为最高出价则不能退还该部分\n                    emit BidRevealed(msg.sender, value, true);\n                } else {\n                    emit BidRevealed(msg.sender, value, false);\n                }\n            } else {\n                emit BidRevealed(msg.sender, 0, false);\n            }\n\n            // 重置该出价，防止重复认领\n            bidToCheck.blindedBid = bytes32(0);\n        }\n\n        // 将应退还金额返还给用户\n        if (refund > 0) {\n            payable(msg.sender).transfer(refund);\n        }\n    }\n\n    /// 用户取回未成功的竞标所冻结的押金\n    function withdraw() external {\n        uint amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            // 防止重入攻击：先置 0\n            pendingReturns[msg.sender] = 0;\n            payable(msg.sender).transfer(amount);\n        }\n    }\n\n    /// 结束拍卖：只能调用一次，将最高出价金额转给受益人\n    function auctionEnd()\n        external\n        onlyAfter(revealEnd) // 只能在披露阶段后调用\n    {\n        if (ended) revert AuctionEndAlreadyCalled();\n\n        emit AuctionEnded(highestBidder, highestBid); // 触发拍卖结束事件\n\n        ended = true;\n\n        beneficiary.transfer(highestBid); // 转账给受益人\n    }\n\n    /// 内部函数：尝试设置新的最高出价\n    /// @param bidder 出价人地址\n    /// @param value 出价金额\n    function placeBid(address bidder, uint value) internal\n            returns (bool success)\n    {\n        if (value <= highestBid) {\n            return false; // 不是最高出价，忽略\n        }\n\n        // 如果已有最高出价者，则先退还之前的出价\n        if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n\n        // 设置新的最高出价者和出价\n        highestBid = value;\n        highestBidder = bidder;\n        return true;\n    }\n    \n    /// 查询竞标开始剩余时间\n    function biddingStartTimeLeft() public view returns (uint) {\n        if (block.timestamp >= biddingStart) return 0;\n        return biddingStart - block.timestamp;\n    }\n    \n    /// 查询竞标阶段剩余时间\n    function biddingTimeLeft() public view returns (uint) {\n        if (block.timestamp >= biddingEnd) return 0;\n        return biddingEnd - block.timestamp;\n    }\n    \n    /// 查询披露阶段剩余时间\n    function revealTimeLeft() public view returns (uint) {\n        if (block.timestamp <= biddingEnd) return 0;\n        if (block.timestamp >= revealEnd) return 0;\n        return revealEnd - block.timestamp;\n    }\n    \n    /// 获取用户的出价数量\n    function getBidCount(address bidder) public view returns (uint) {\n        return bids[bidder].length;\n    }\n    \n    /// 获取竞标阶段状态\n    /// @return 0-未开始 1-竞标阶段 2-披露阶段 3-拍卖结束\n    function getAuctionPhase() public view returns (uint) {\n        if (block.timestamp < biddingStart) return 0; // 未开始\n        if (block.timestamp < biddingEnd) return 1;   // 竞标阶段\n        if (block.timestamp < revealEnd) return 2;    // 披露阶段\n        return 3; // 拍卖结束\n    }\n} "
    },
    "contracts/BlindAuctionFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.5;\n\nimport \"./BlindAuction.sol\";\n\n/// @title 盲拍工厂合约\n/// @notice 用于创建和管理多个盲拍合约\ncontract BlindAuctionFactory {\n    // 事件：新拍卖合约创建\n    event AuctionCreated(\n        address indexed auctionAddress,\n        address indexed beneficiary,\n        uint biddingStart,\n        uint biddingEnd,\n        uint revealEnd,\n        string metadata\n    );\n\n    // 用户创建的拍卖列表\n    mapping(address => address[]) public userAuctions;\n\n    // 所有创建的拍卖列表\n    address[] public allAuctions;\n\n    /// @notice 创建新的盲拍合约\n    /// @param startTime 竞标开始时间（时间戳）\n    /// @param biddingTime 竞标阶段的持续时间（秒）\n    /// @param revealTime 披露阶段的持续时间（秒）\n    /// @param metadata 拍卖物品的元数据（JSON字符串）\n    /// @return 新创建的盲拍合约地址\n    function createAuction(\n        uint startTime,\n        uint biddingTime,\n        uint revealTime,\n        string memory metadata\n    ) external returns (address) {\n        // 创建新的盲拍合约\n        BlindAuction newAuction = new BlindAuction(\n            startTime,\n            biddingTime,\n            revealTime,\n            payable(msg.sender)\n        );\n\n        address auctionAddress = address(newAuction);\n\n        // 记录用户创建的拍卖\n        userAuctions[msg.sender].push(auctionAddress);\n        \n        // 添加到所有拍卖列表\n        allAuctions.push(auctionAddress);\n\n        // 触发事件\n        emit AuctionCreated(\n            auctionAddress,\n            msg.sender,\n            startTime,\n            startTime + biddingTime,\n            startTime + biddingTime + revealTime,\n            metadata\n        );\n\n        return auctionAddress;\n    }\n\n    /// @notice 获取用户创建的所有拍卖\n    /// @param user 用户地址\n    /// @return 该用户创建的所有盲拍合约地址数组\n    function getUserAuctions(address user) external view returns (address[] memory) {\n        return userAuctions[user];\n    }\n\n    /// @notice 获取所有创建的拍卖数量\n    /// @return 拍卖总数\n    function getAuctionCount() external view returns (uint) {\n        return allAuctions.length;\n    }\n\n    /// @notice 分页获取所有拍卖\n    /// @param offset 起始索引\n    /// @param limit 每页数量\n    /// @return 拍卖地址数组\n    function getAuctions(uint offset, uint limit) external view returns (address[] memory) {\n        uint totalCount = allAuctions.length;\n        \n        // 调整limit，确保不会越界\n        if (offset >= totalCount) {\n            return new address[](0);\n        }\n        \n        uint actualLimit = limit;\n        if (offset + limit > totalCount) {\n            actualLimit = totalCount - offset;\n        }\n        \n        address[] memory result = new address[](actualLimit);\n        for (uint i = 0; i < actualLimit; i++) {\n            result[i] = allAuctions[offset + i];\n        }\n        \n        return result;\n    }\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}